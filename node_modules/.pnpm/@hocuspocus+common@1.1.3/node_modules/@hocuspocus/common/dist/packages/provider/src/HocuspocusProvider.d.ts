import * as Y from 'yjs';
import { Awareness } from 'y-protocols/awareness';
import * as mutex from 'lib0/mutex';
import type { Event, CloseEvent, MessageEvent } from 'ws';
import EventEmitter from './EventEmitter';
import { ConstructableOutgoingMessage, onAuthenticationFailedParameters, onCloseParameters, onDisconnectParameters, onMessageParameters, onOpenParameters, onOutgoingMessageParameters, onStatelessParameters, onStatusParameters, onSyncedParameters, WebSocketStatus } from './types';
import { onAwarenessChangeParameters, onAwarenessUpdateParameters } from '.';
export declare type HocuspocusProviderConfiguration = Required<Pick<CompleteHocuspocusProviderConfiguration, 'url' | 'name'>> & Partial<CompleteHocuspocusProviderConfiguration>;
export interface CompleteHocuspocusProviderConfiguration {
    /**
     * URL of your @hocuspocus/server instance
     */
    url: string;
    /**
     * The identifier/name of your document
     */
    name: string;
    /**
     * The actual Y.js document
     */
    document: Y.Doc;
    /**
     * Pass `false` to start the connection manually.
     */
    connect: boolean;
    /**
     * Pass false to disable broadcasting between browser tabs.
     */
    broadcast: boolean;
    /**
     * An Awareness instance to keep the presence state of all clients.
     */
    awareness: Awareness;
    /**
     * A token that’s sent to the backend for authentication purposes.
     */
    token: string | (() => string) | (() => Promise<string>) | null;
    /**
     * URL parameters that should be added.
     */
    parameters: {
        [key: string]: any;
    };
    /**
     * An optional WebSocket polyfill, for example for Node.js
     */
    WebSocketPolyfill: any;
    /**
     * Force syncing the document in the defined interval.
     */
    forceSyncInterval: false | number;
    /**
     * Disconnect when no message is received for the defined amount of milliseconds.
     */
    messageReconnectTimeout: number;
    /**
     * The delay between each attempt in milliseconds. You can provide a factor to have the delay grow exponentially.
     */
    delay: number;
    /**
     * The intialDelay is the amount of time to wait before making the first attempt. This option should typically be 0 since you typically want the first attempt to happen immediately.
     */
    initialDelay: number;
    /**
     * The factor option is used to grow the delay exponentially.
     */
    factor: number;
    /**
     * The maximum number of attempts or 0 if there is no limit on number of attempts.
     */
    maxAttempts: number;
    /**
     * minDelay is used to set a lower bound of delay when jitter is enabled. This property has no effect if jitter is disabled.
     */
    minDelay: number;
    /**
     * The maxDelay option is used to set an upper bound for the delay when factor is enabled. A value of 0 can be provided if there should be no upper bound when calculating delay.
     */
    maxDelay: number;
    /**
     * If jitter is true then the calculated delay will be a random integer value between minDelay and the calculated delay for the current iteration.
     */
    jitter: boolean;
    /**
     * A timeout in milliseconds. If timeout is non-zero then a timer is set using setTimeout. If the timeout is triggered then future attempts will be aborted.
     */
    timeout: number;
    onAuthenticated: () => void;
    onAuthenticationFailed: (data: onAuthenticationFailedParameters) => void;
    onOpen: (data: onOpenParameters) => void;
    onConnect: () => void;
    onMessage: (data: onMessageParameters) => void;
    onOutgoingMessage: (data: onOutgoingMessageParameters) => void;
    onStatus: (data: onStatusParameters) => void;
    onSynced: (data: onSyncedParameters) => void;
    onDisconnect: (data: onDisconnectParameters) => void;
    onClose: (data: onCloseParameters) => void;
    onDestroy: () => void;
    onAwarenessUpdate: (data: onAwarenessUpdateParameters) => void;
    onAwarenessChange: (data: onAwarenessChangeParameters) => void;
    onStateless: (data: onStatelessParameters) => void;
    /**
     * Don’t output any warnings.
     */
    quiet: boolean;
}
export declare class HocuspocusProvider extends EventEmitter {
    configuration: CompleteHocuspocusProviderConfiguration;
    subscribedToBroadcastChannel: boolean;
    webSocket: WebSocket | null;
    shouldConnect: boolean;
    status: WebSocketStatus;
    isSynced: boolean;
    unsyncedChanges: number;
    isAuthenticated: boolean;
    lastMessageReceived: number;
    mux: mutex.mutex;
    intervals: any;
    connectionAttempt: {
        resolve: (value?: any) => void;
        reject: (reason?: any) => void;
    } | null;
    constructor(configuration: HocuspocusProviderConfiguration);
    setConfiguration(configuration?: Partial<HocuspocusProviderConfiguration>): void;
    boundConnect: () => Promise<unknown>;
    cancelWebsocketRetry?: () => void;
    connect(): Promise<unknown>;
    createWebSocketConnection(): Promise<unknown>;
    resolveConnectionAttempt(): void;
    stopConnectionAttempt(): void;
    rejectConnectionAttempt(): void;
    get document(): Y.Doc;
    get awareness(): Awareness;
    get hasUnsyncedChanges(): boolean;
    checkConnection(): void;
    forceSync(): void;
    boundBeforeUnload: () => void;
    beforeUnload(): void;
    registerEventListeners(): void;
    sendStateless(payload: string): void;
    documentUpdateHandler(update: Uint8Array, origin: any): void;
    awarenessUpdateHandler({ added, updated, removed }: any, origin: any): void;
    permissionDeniedHandler(reason: string): void;
    authenticatedHandler(): void;
    get serverUrl(): string;
    get url(): string;
    get synced(): boolean;
    set synced(state: boolean);
    receiveStateless(payload: string): void;
    get isAuthenticationRequired(): boolean;
    disconnect(): void;
    onOpen(event: Event): Promise<void>;
    getToken(): Promise<string | null>;
    startSync(): void;
    send(Message: ConstructableOutgoingMessage, args: any, broadcast?: boolean): void;
    onMessage(event: MessageEvent): void;
    onClose(event: CloseEvent): void;
    destroy(): void;
    get broadcastChannel(): string;
    boundBroadcastChannelSubscriber: (data: ArrayBuffer) => void;
    broadcastChannelSubscriber(data: ArrayBuffer): void;
    subscribeToBroadcastChannel(): void;
    disconnectBroadcastChannel(): void;
    broadcast(Message: ConstructableOutgoingMessage, args?: any): void;
    setAwarenessField(key: string, value: any): void;
}

{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@tiptap+extension-ordered-list@2.14.0_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-ordered-list/src/ordered-list.ts"],
  "sourcesContent": ["import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string,\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>,\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean,\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType,\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const inputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start')\n            ? parseInt(element.getAttribute('start') || '', 10)\n            : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands, chain }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run()\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: inputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [\n      inputRule,\n    ]\n  },\n})\n"],
  "mappings": ";;;;;;;;;;;;;AAEA,IAAM,eAAe;AACrB,IAAM,gBAAgB;AA+Cf,IAAM,aAAa;AAQb,IAAA,cAAc,KAAK,OAA2B;EACzD,MAAM;EAEN,aAAU;AACR,WAAO;MACL,cAAc;MACd,gBAAgB,CAAA;MAChB,WAAW;MACX,gBAAgB;;;EAIpB,OAAO;EAEP,UAAO;AACL,WAAO,GAAG,KAAK,QAAQ,YAAY;;EAGrC,gBAAa;AACX,WAAO;MACL,OAAO;QACL,SAAS;QACT,WAAW,aAAU;AACnB,iBAAO,QAAQ,aAAa,OAAO,IAC/B,SAAS,QAAQ,aAAa,OAAO,KAAK,IAAI,EAAE,IAChD;;MAEP;MACD,MAAM;QACJ,SAAS;QACT,WAAW,aAAW,QAAQ,aAAa,MAAM;MAClD;;;EAIL,YAAS;AACP,WAAO;MACL;QACE,KAAK;MACN;;;EAIL,WAAW,EAAE,eAAc,GAAE;AAC3B,UAAM,EAAE,OAAO,GAAG,uBAAsB,IAAK;AAE7C,WAAO,UAAU,IACb,CAAC,MAAM,gBAAgB,KAAK,QAAQ,gBAAgB,sBAAsB,GAAG,CAAC,IAC9E,CAAC,MAAM,gBAAgB,KAAK,QAAQ,gBAAgB,cAAc,GAAG,CAAC;;EAG5E,cAAW;AACT,WAAO;MACL,mBAAmB,MAAM,CAAC,EAAE,UAAU,MAAK,MAAM;AAC/C,YAAI,KAAK,QAAQ,gBAAgB;AAC/B,iBAAO,MAAK,EAAG,WAAW,KAAK,MAAM,KAAK,QAAQ,cAAc,KAAK,QAAQ,SAAS,EAAE,iBAAiB,cAAc,KAAK,OAAO,cAAc,aAAa,CAAC,EAAE,IAAG;;AAEtK,eAAO,SAAS,WAAW,KAAK,MAAM,KAAK,QAAQ,cAAc,KAAK,QAAQ,SAAS;;;;EAK7F,uBAAoB;AAClB,WAAO;MACL,eAAe,MAAM,KAAK,OAAO,SAAS,kBAAiB;;;EAI/D,gBAAa;AACX,QAAI,YAAY,kBAAkB;MAChC,MAAM;MACN,MAAM,KAAK;MACX,eAAe,YAAU,EAAE,OAAO,CAAC,MAAM,CAAC,EAAC;MAC3C,eAAe,CAAC,OAAO,SAAS,KAAK,aAAa,KAAK,MAAM,UAAU,CAAC,MAAM,CAAC;IAChF,CAAA;AAED,QAAI,KAAK,QAAQ,aAAa,KAAK,QAAQ,gBAAgB;AACzD,kBAAY,kBAAkB;QAC5B,MAAM;QACN,MAAM,KAAK;QACX,WAAW,KAAK,QAAQ;QACxB,gBAAgB,KAAK,QAAQ;QAC7B,eAAe,YAAU,EAAE,OAAO,CAAC,MAAM,CAAC,GAAG,GAAG,KAAK,OAAO,cAAc,aAAa,EAAC;QACxF,eAAe,CAAC,OAAO,SAAS,KAAK,aAAa,KAAK,MAAM,UAAU,CAAC,MAAM,CAAC;QAC/E,QAAQ,KAAK;MACd,CAAA;;AAEH,WAAO;MACL;;;AAGL,CAAA;",
  "names": []
}

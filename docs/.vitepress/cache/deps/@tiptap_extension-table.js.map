{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/tablemap.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/schema.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/util.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/cellselection.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/copypaste.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/input.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/fixtables.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/commands.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/tableview.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/columnresizing.js", "../../../../node_modules/.pnpm/@_ueberdosis+prosemirror-tables@1.1.3/node_modules/@_ueberdosis/prosemirror-tables/src/index.js", "../../../../node_modules/.pnpm/@tiptap+extension-table@2.0.0-beta.202_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-table/src/TableView.ts", "../../../../node_modules/.pnpm/@tiptap+extension-table@2.0.0-beta.202_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-table/src/utilities/createCell.ts", "../../../../node_modules/.pnpm/@tiptap+extension-table@2.0.0-beta.202_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-table/src/utilities/getTableNodeTypes.ts", "../../../../node_modules/.pnpm/@tiptap+extension-table@2.0.0-beta.202_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-table/src/utilities/createTable.ts", "../../../../node_modules/.pnpm/@tiptap+extension-table@2.0.0-beta.202_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-table/src/utilities/isCellSelection.ts", "../../../../node_modules/.pnpm/@tiptap+extension-table@2.0.0-beta.202_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-table/src/utilities/deleteTableWhenAllCellsSelected.ts", "../../../../node_modules/.pnpm/@tiptap+extension-table@2.0.0-beta.202_@tiptap+core@2.0.0-beta.202/node_modules/@tiptap/extension-table/src/table.ts"],
  "sourcesContent": ["// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\n\nlet readFromCache, addToCache;\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != 'undefined') {\n  // eslint-disable-next-line\n  let cache = new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  let cache = [],\n    cacheSize = 10,\n    cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return (cache[cachePos++] = value);\n  };\n}\n\nexport class Rect {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n}\n\n// ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\nexport class TableMap {\n  constructor(width, height, map, problems) {\n    // :: number The width of the table\n    this.width = width;\n    // :: number The table's height\n    this.height = height;\n    // :: [number] A width * height array with the start position of\n    // the cell covering that part of the table in each slot\n    this.map = map;\n    // An optional array of problems (cell overlap or non-rectangular\n    // shape) for the table, used by the table normalizer.\n    this.problems = problems;\n  }\n\n  // :: (number) → Rect\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      let curPos = this.map[i];\n      if (curPos != pos) continue;\n      let left = i % this.width,\n        top = (i / this.width) | 0;\n      let right = left + 1,\n        bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++)\n        right++;\n      for (\n        let j = 1;\n        bottom < this.height && this.map[i + this.width * j] == curPos;\n        j++\n      )\n        bottom++;\n      return new Rect(left, top, right, bottom);\n    }\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  }\n\n  // :: (number) → number\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++)\n      if (this.map[i] == pos) return i % this.width;\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  }\n\n  // :: (number, string, number) → ?number\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    let { left, right, top, bottom } = this.findCell(pos);\n    if (axis == 'horiz') {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n\n  // :: (number, number) → Rect\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    let {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA,\n    } = this.findCell(a);\n    let {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB,\n    } = this.findCell(b);\n    return new Rect(\n      Math.min(leftA, leftB),\n      Math.min(topA, topB),\n      Math.max(rightA, rightB),\n      Math.max(bottomA, bottomB),\n    );\n  }\n\n  // :: (Rect) → [number]\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    let result = [],\n      seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let index = row * this.width + col,\n          pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (\n          (col != rect.left || !col || this.map[index - 1] != pos) &&\n          (row != rect.top || !row || this.map[index - this.width] != pos)\n        )\n          result.push(pos);\n      }\n    }\n    return result;\n  }\n\n  // :: (number, number, Node) → number\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      let rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width,\n          rowEndIndex = (row + 1) * this.width;\n        // Skip past cells from previous rows (via rowspan)\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n\n  // :: (Node) → TableMap\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n}\n\n// Compute a table map.\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != 'table')\n    throw new RangeError('Not a table node: ' + table.type.name);\n  let width = findWidth(table),\n    height = table.childCount;\n  let map = [],\n    mapPos = 0,\n    problems = null,\n    colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    let rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      let cellNode = rowNode.child(i),\n        { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: 'overlong_rowspan',\n            pos,\n            n: rowspan - h,\n          });\n          break;\n        }\n        let start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: 'collision',\n              row,\n              pos,\n              n: colspan - w,\n            });\n          let colW = colwidth && colwidth[w];\n          if (colW) {\n            let widthIndex = ((start + w) % width) * 2,\n              prev = colWidths[widthIndex];\n            if (\n              prev == null ||\n              (prev != colW && colWidths[widthIndex + 1] == 1)\n            ) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    let expectedPos = (row + 1) * width,\n      missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: 'missing', row, n: missing });\n    pos++;\n  }\n\n  let tableMap = new TableMap(width, height, map, problems),\n    badWidths = false;\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n\n  return tableMap;\n}\n\nfunction findWidth(table) {\n  let width = -1,\n    hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    let rowNode = table.child(row),\n      rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        let prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          let cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      let cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  for (let i = 0, seen = {}; i < map.map.length; i++) {\n    let pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    let node = table.nodeAt(pos),\n      updated = null;\n    for (let j = 0; j < node.attrs.colspan; j++) {\n      let col = (i + j) % map.width,\n        colWidth = colWidths[col * 2];\n      if (\n        colWidth != null &&\n        (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth)\n      )\n        (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: 'colwidth mismatch',\n        pos,\n        colwidth: updated,\n      });\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  let result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n", "// Helper for creating a schema that supports tables.\n\nfunction getCellAttrs(dom, extraAttrs) {\n  let widthAttr = dom.getAttribute('data-colwidth');\n  let widths =\n    widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr)\n      ? widthAttr.split(',').map((s) => Number(s))\n      : null;\n  let colspan = Number(dom.getAttribute('colspan') || 1);\n  let result = {\n    colspan,\n    rowspan: Number(dom.getAttribute('rowspan') || 1),\n    colwidth: widths && widths.length == colspan ? widths : null,\n  };\n  for (let prop in extraAttrs) {\n    let getter = extraAttrs[prop].getFromDOM;\n    let value = getter && getter(dom);\n    if (value != null) result[prop] = value;\n  }\n  return result;\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  let attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs['data-colwidth'] = node.attrs.colwidth.join(',');\n  for (let prop in extraAttrs) {\n    let setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\n\n// :: (Object) → Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) → any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\nexport function tableNodes(options) {\n  let extraAttrs = options.cellAttributes || {};\n  let cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null },\n  };\n  for (let prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n\n  return {\n    table: {\n      content: 'table_row+',\n      tableRole: 'table',\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: 'table' }],\n      toDOM() {\n        return ['table', ['tbody', 0]];\n      },\n    },\n    table_row: {\n      content: '(table_cell | table_header)*',\n      tableRole: 'row',\n      parseDOM: [{ tag: 'tr' }],\n      toDOM() {\n        return ['tr', 0];\n      },\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'td', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['td', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'header_cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'th', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['th', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n  };\n}\n\nexport function tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (let name in schema.nodes) {\n      let type = schema.nodes[name],\n        role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n", "// Various helper function for working with tables\n\nimport { PluginKey } from 'prosemirror-state';\n\nimport { TableMap } from './tablemap';\nimport { tableNodeTypes } from './schema';\n\nexport const key = new PluginKey('selectingCells');\n\nexport function cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == 'row')\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\n\nexport function cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === 'cell' || role === 'header_cell') return $pos.node(d);\n  }\n  return null;\n}\n\nexport function isInTable(state) {\n  let $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == 'row') return true;\n  return false;\n}\n\nexport function selectionCell(state) {\n  let sel = state.selection;\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos\n      ? sel.$anchorCell\n      : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == 'cell') {\n    return sel.$anchor;\n  }\n  return cellAround(sel.$head) || cellNear(sel.$head);\n}\n\nfunction cellNear($pos) {\n  for (\n    let after = $pos.nodeAfter, pos = $pos.pos;\n    after;\n    after = after.firstChild, pos++\n  ) {\n    let role = after.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos);\n  }\n  for (\n    let before = $pos.nodeBefore, pos = $pos.pos;\n    before;\n    before = before.lastChild, pos--\n  ) {\n    let role = before.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell')\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\n\nexport function pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == 'row' && $pos.nodeAfter;\n}\n\nexport function moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\n\nexport function inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);\n}\n\nexport function findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\n\nexport function colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\n\nexport function nextCell($pos, axis, dir) {\n  let start = $pos.start(-1),\n    map = TableMap.get($pos.node(-1));\n  let moved = map.nextCell($pos.pos - start, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(start + moved);\n}\n\nexport function setAttr(attrs, name, value) {\n  let result = {};\n  for (let prop in attrs) result[prop] = attrs[prop];\n  result[name] = value;\n  return result;\n}\n\nexport function removeColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan - n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\n\nexport function addColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan + n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\n\nexport function columnIsHeader(map, table, col) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n", "// This file defines a ProseMirror selection subclass that models\n// table cell selections. The table plugin needs to be active to wire\n// in the user interaction part of table selections (so that you\n// actually get such selections when you select across cells).\n\nimport {\n  Selection,\n  TextSelection,\n  NodeSelection,\n  SelectionRange,\n} from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { Fragment, Slice } from 'prosemirror-model';\n\nimport { inSameTable, pointsAtCell, setAttr, removeColSpan } from './util';\nimport { TableMap } from './tablemap';\n\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\nexport class CellSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    let table = $anchorCell.node(-1),\n      map = TableMap.get(table),\n      start = $anchorCell.start(-1);\n    let rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    let cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - start);\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - start);\n    let ranges = cells.map((pos) => {\n      let cell = table.nodeAt(pos),\n        from = pos + start + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size),\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n    this.$anchorCell = $anchorCell;\n    // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n    this.$headCell = $headCell;\n  }\n\n  map(doc, mapping) {\n    let $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    let $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (\n      pointsAtCell($anchorCell) &&\n      pointsAtCell($headCell) &&\n      inSameTable($anchorCell, $headCell)\n    ) {\n      let tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n\n  // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    let table = this.$anchorCell.node(-1),\n      map = TableMap.get(table),\n      start = this.$anchorCell.start(-1);\n    let rect = map.rectBetween(\n      this.$anchorCell.pos - start,\n      this.$headCell.pos - start,\n    );\n    let seen = {},\n      rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      let rowContent = [];\n      for (\n        let index = row * map.width + rect.left, col = rect.left;\n        col < rect.right;\n        col++, index++\n      ) {\n        let pos = map.map[index];\n        if (!seen[pos]) {\n          seen[pos] = true;\n          let cellRect = map.findCell(pos),\n            cell = table.nodeAt(pos);\n          let extraLeft = rect.left - cellRect.left,\n            extraRight = cellRect.right - rect.right;\n          if (extraLeft > 0 || extraRight > 0) {\n            let attrs = cell.attrs;\n            if (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft);\n            if (extraRight > 0)\n              attrs = removeColSpan(\n                attrs,\n                attrs.colspan - extraRight,\n                extraRight,\n              );\n            if (cellRect.left < rect.left)\n              cell = cell.type.createAndFill(attrs);\n            else cell = cell.type.create(attrs, cell.content);\n          }\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            let attrs = setAttr(\n              cell.attrs,\n              'rowspan',\n              Math.min(cellRect.bottom, rect.bottom) -\n                Math.max(cellRect.top, rect.top),\n            );\n            if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs);\n            else cell = cell.type.create(attrs, cell.content);\n          }\n          rowContent.push(cell);\n        }\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    const fragment =\n      this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n\n  replace(tr, content = Slice.empty) {\n    let mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let { $from, $to } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content,\n      );\n    }\n    let sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1,\n    );\n    if (sel) tr.setSelection(sel);\n  }\n\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n\n  forEachCell(f) {\n    let table = this.$anchorCell.node(-1),\n      map = TableMap.get(table),\n      start = this.$anchorCell.start(-1);\n    let cells = map.cellsInRect(\n      map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start),\n    );\n    for (let i = 0; i < cells.length; i++)\n      f(table.nodeAt(cells[i]), start + cells[i]);\n  }\n\n  // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    let anchorTop = this.$anchorCell.index(-1),\n      headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    let anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n      headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n      start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n      headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          start + map.map[map.width * (map.height - 1) + headRect.right - 1],\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(start + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          start + map.map[map.width * (map.height - 1) + anchorRect.right - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    let map = TableMap.get(this.$anchorCell.node(-1)),\n      start = this.$anchorCell.start(-1);\n    let anchorLeft = map.colCount(this.$anchorCell.pos - start),\n      headLeft = map.colCount(this.$headCell.pos - start);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    let anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n      headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n\n  eq(other) {\n    return (\n      other instanceof CellSelection &&\n      other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n    );\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n      start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n      headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]);\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          start + map.map[map.width * (headRect.top + 1) - 1],\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(start + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          start + map.map[map.width * (anchorRect.top + 1) - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  toJSON() {\n    return {\n      type: 'cell',\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos,\n    };\n  }\n\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n\n  // :: (Node, number, ?number) → CellSelection\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n}\n\nCellSelection.prototype.visible = false;\n\nSelection.jsonID('cell', CellSelection);\n\nclass CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    let $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n    if (\n      $anchorCell.parent.type.spec.tableRole == 'row' &&\n      $headCell.parent.type.spec.tableRole == 'row' &&\n      $anchorCell.index() < $anchorCell.parent.childCount &&\n      $headCell.index() < $headCell.parent.childCount &&\n      inSameTable($anchorCell, $headCell)\n    )\n      return new CellSelection($anchorCell, $headCell);\n    else return Selection.near($headCell, 1);\n  }\n}\n\nexport function drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  let cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: 'selectedCell' }),\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false; // Cheap elimination\n  let afterFrom = $from.pos,\n    beforeTo = $to.pos,\n    depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return (\n    afterFrom == beforeTo &&\n    /row|table/.test($from.node(depth).type.spec.tableRole)\n  );\n}\n\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n\n  for (let i = $from.depth; i > 0; i--) {\n    let node = $from.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    let node = $to.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nexport function normalizeSelection(state, tr, allowTableNodeSelection) {\n  let sel = (tr || state).selection,\n    doc = (tr || state).doc,\n    normalize,\n    role;\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == 'cell' || role == 'header_cell') {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == 'row') {\n      let $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      let map = TableMap.get(sel.node),\n        start = sel.from + 1;\n      let lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n", "// Utilities used for copy/paste handling.\n//\n// This module handles pasting cell content into tables, or pasting\n// anything into a cell selection, as replacing a block of cells with\n// the content of the selection. When pasting cells into a cell, that\n// involves placing the block of pasted content so that its top left\n// aligns with the selection cell, optionally extending the table to\n// the right or bottom to make sure it is large enough. Pasting into a\n// cell selection is different, here the cells in the selection are\n// clipped to the selection's rectangle, optionally repeating the\n// pasted cells when they are smaller than the selection.\n\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { Transform } from 'prosemirror-transform';\n\nimport { setAttr, removeColSpan } from './util';\nimport { TableMap } from './tablemap';\nimport { CellSelection } from './cellselection';\nimport { tableNodeTypes } from './schema';\n\n// Utilities to help with copying and pasting table cells\n\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\nexport function pastedCells(slice) {\n  if (!slice.size) return null;\n  let { content, openStart, openEnd } = slice;\n  while (\n    content.childCount == 1 &&\n    ((openStart > 0 && openEnd > 0) ||\n      content.firstChild.type.spec.tableRole == 'table')\n  ) {\n    openStart--;\n    openEnd--;\n    content = content.firstChild.content;\n  }\n  let first = content.firstChild,\n    role = first.type.spec.tableRole;\n  let schema = first.type.schema,\n    rows = [];\n  if (role == 'row') {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      let left = i ? 0 : Math.max(0, openStart - 1);\n      let right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice(cells, left, right),\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == 'cell' || role == 'header_cell') {\n    rows.push(\n      openStart || openEnd\n        ? fitSlice(\n            tableNodeTypes(schema).row,\n            new Slice(content, openStart, openEnd),\n          ).content\n        : content,\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\n\n// : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema, rows) {\n  let widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    let row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      let { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty);\n    if (widths[r] < width) {\n      let empty = tableNodeTypes(schema).cell.createAndFill(),\n        cells = [];\n      for (let i = widths[r]; i < width; i++) cells.push(empty);\n      rows[r] = rows[r].append(Fragment.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\n\nexport function fitSlice(nodeType, slice) {\n  let node = nodeType.createAndFill();\n  let tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\n\n// : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\nexport function clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    let added = [],\n      newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      let frag = rows[row],\n        cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.create(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth,\n            ),\n            cell.content,\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    let newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      let cells = [],\n        source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            setAttr(\n              cell.attrs,\n              'rowspan',\n              Math.max(1, newHeight - cell.attrs.rowspan),\n            ),\n            cell.content,\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n\n  return { width, height, rows };\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  let schema = tr.doc.type.schema,\n    types = tableNodeTypes(schema),\n    empty,\n    emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      let rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      let cells = [],\n        add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    let cells = [];\n    for (\n      let i = 0, start = (map.height - 1) * map.width;\n      i < Math.max(map.width, width);\n      i++\n    ) {\n      let header =\n        i >= map.width\n          ? false\n          : table.nodeAt(map.map[start + i]).type == types.header_cell;\n      cells.push(\n        header\n          ? emptyHead || (emptyHead = types.header_cell.createAndFill())\n          : empty || (empty = types.cell.createAndFill()),\n      );\n    }\n\n    let emptyRow = types.row.create(null, Fragment.from(cells)),\n      rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    let index = top * map.width + col,\n      pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos);\n      let { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapFrom).map(pos + start),\n        null,\n        setAttr(cell.attrs, 'rowspan', top - cellTop),\n      );\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill(\n          setAttr(cell.attrs, 'rowspan', cellTop + cell.attrs.rowspan - top),\n        ),\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    let index = row * map.width + left,\n      pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos),\n        cellLeft = map.colCount(pos);\n      let updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft),\n        ),\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)),\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\n\n// Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\nexport function insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc,\n    map = TableMap.get(table);\n  let { top, left } = rect;\n  let right = left + cells.width,\n    bottom = top + cells.height;\n  let tr = state.tr,\n    mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (\n    isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)\n  )\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n\n  for (let row = top; row < bottom; row++) {\n    let from = map.positionAt(row, left, table),\n      to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice(cells.rows[row - top], 0, 0),\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table)),\n    ),\n  );\n  dispatch(tr);\n}\n", "// This file defines a number of helpers for wiring up user input to\n// table-related functionality.\n\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { Selection, TextSelection } from 'prosemirror-state';\nimport { keydownHandler } from 'prosemirror-keymap';\n\nimport {\n  key,\n  nextCell,\n  cellAround,\n  inSameTable,\n  isInTable,\n  selectionCell,\n} from './util';\nimport { CellSelection } from './cellselection';\nimport { TableMap } from './tablemap';\nimport { pastedCells, fitSlice, clipCells, insertCells } from './copypaste';\nimport { tableNodeTypes } from './schema';\n\nexport const handleKeyDown = keydownHandler({\n  ArrowLeft: arrow('horiz', -1),\n  ArrowRight: arrow('horiz', 1),\n  ArrowUp: arrow('vert', -1),\n  ArrowDown: arrow('vert', 1),\n\n  'Shift-ArrowLeft': shiftArrow('horiz', -1),\n  'Shift-ArrowRight': shiftArrow('horiz', 1),\n  'Shift-ArrowUp': shiftArrow('vert', -1),\n  'Shift-ArrowDown': shiftArrow('vert', 1),\n\n  Backspace: deleteCellSelection,\n  'Mod-Backspace': deleteCellSelection,\n  Delete: deleteCellSelection,\n  'Mod-Delete': deleteCellSelection,\n});\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\n\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(sel.$headCell, dir),\n      );\n    }\n    if (axis != 'horiz' && !sel.empty) return false;\n    let end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == 'horiz') {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(state.doc.resolve(sel.head + dir), dir),\n      );\n    } else {\n      let $cell = state.doc.resolve(end),\n        $next = nextCell($cell, axis, dir),\n        newSel;\n      if ($next) newSel = Selection.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\n\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n    if (!(sel instanceof CellSelection)) {\n      let end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      sel = new CellSelection(state.doc.resolve(end));\n    }\n    let $head = nextCell(sel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(sel.$anchorCell, $head),\n    );\n  };\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  let sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    let tr = state.tr,\n      baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice(baseContent, 0, 0),\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\nexport function handleTripleClick(view, pos) {\n  let doc = view.state.doc,\n    $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\n\nexport function handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice),\n    sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice),\n          ),\n        ],\n      };\n    let table = sel.$anchorCell.node(-1),\n      start = sel.$anchorCell.start(-1);\n    let rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start,\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    let $cell = selectionCell(view.state),\n      start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells,\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function handleMouseDown(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n\n  let startDOMCell = domInCell(view, startEvent.target),\n    $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (\n    startEvent.shiftKey &&\n    startDOMCell &&\n    ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n    cellUnderMouse(view, startEvent).pos != $anchor.pos\n  ) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return;\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor, event) {\n    let $head = cellUnderMouse(view, event);\n    let starting = key.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor;\n      else return;\n    }\n    let selection = new CellSelection($anchor, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      let tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(key, $anchor.pos);\n      view.dispatch(tr);\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop() {\n    view.root.removeEventListener('mouseup', stop);\n    view.root.removeEventListener('dragstart', stop);\n    view.root.removeEventListener('mousemove', move);\n    if (key.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(key, -1));\n  }\n\n  function move(event) {\n    let anchor = key.getState(view.state),\n      $anchor;\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) return stop();\n    }\n    if ($anchor) setCellSelection($anchor, event);\n  }\n  view.root.addEventListener('mouseup', stop);\n  view.root.addEventListener('dragstart', stop);\n  view.root.addEventListener('mousemove', move);\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return null;\n  let { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    let parent = $head.node(d),\n      index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (\n      parent.type.spec.tableRole == 'cell' ||\n      parent.type.spec.tableRole == 'header_cell'\n    ) {\n      let cellPos = $head.before(d);\n      let dirStr =\n        axis == 'vert' ? (dir > 0 ? 'down' : 'up') : dir > 0 ? 'right' : 'left';\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode)\n    if (dom.nodeName == 'TD' || dom.nodeName == 'TH') return dom;\n}\n\nfunction cellUnderMouse(view, event) {\n  let mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n", "// This file defines helpers for normalizing tables, making sure no\n// cells overlap (which can happen, if you have the wrong col- and\n// rowspans) and that each row has the same width. Uses the problems\n// reported by `TableMap`.\n\nimport { PluginKey } from 'prosemirror-state';\nimport { TableMap } from './tablemap';\nimport { setAttr, removeColSpan } from './util';\nimport { tableNodeTypes } from './schema';\n\nexport const fixTablesKey = new PluginKey('fix-tables');\n\n// Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\nfunction changedDescendants(old, cur, offset, f) {\n  let oldSize = old.childCount,\n    curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    let child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\n\n// :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\nexport function fixTables(state, oldState) {\n  let tr,\n    check = (node, pos) => {\n      if (node.type.spec.tableRole == 'table')\n        tr = fixTable(state, node, pos, tr);\n    };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\n\n// : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nexport function fixTable(state, table, tablePos, tr) {\n  let map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  let mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    let prob = map.problems[i];\n    if (prob.type == 'collision') {\n      let cell = table.nodeAt(prob.pos);\n      for (let j = 0; j < cell.attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n),\n      );\n    } else if (prob.type == 'missing') {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == 'overlong_rowspan') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - prob.n),\n      );\n    } else if (prob.type == 'colwidth mismatch') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        setAttr(cell.attrs, 'colwidth', prob.colwidth),\n      );\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    let row = table.child(i);\n    let end = pos + row.nodeSize;\n    let add = mustAdd[i];\n    if (add > 0) {\n      let tableNodeType = 'cell';\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole;\n      }\n      let nodes = [];\n      for (let j = 0; j < add; j++)\n        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());\n      let side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n", "// This file defines a number of table-related commands.\n\nimport { TextSelection } from 'prosemirror-state';\nimport { Fragment } from 'prosemirror-model';\n\nimport { Rect, TableMap } from './tablemap';\nimport { CellSelection } from './cellselection';\nimport {\n  addColSpan,\n  cellAround,\n  cellWrapping,\n  columnIsHeader,\n  isInTable,\n  moveCellForward,\n  removeColSpan,\n  selectionCell,\n  setAttr,\n} from './util';\nimport { tableNodeTypes } from './schema';\n\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\nexport function selectedRect(state) {\n  let sel = state.selection,\n    $pos = selectionCell(state);\n  let table = $pos.node(-1),\n    tableStart = $pos.start(-1),\n    map = TableMap.get(table);\n  let rect;\n  if (sel instanceof CellSelection)\n    rect = map.rectBetween(\n      sel.$anchorCell.pos - tableStart,\n      sel.$headCell.pos - tableStart,\n    );\n  else rect = map.findCell($pos.pos - tableStart);\n  rect.tableStart = tableStart;\n  rect.map = map;\n  rect.table = table;\n  return rect;\n}\n\n// Add a column at the given position in a table.\nexport function addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn))\n    refColumn = col == 0 || col == map.width ? null : 0;\n\n  for (let row = 0; row < map.height; row++) {\n    let index = row * map.width + col;\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      let pos = map.map[index],\n        cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos)),\n      );\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1;\n    } else {\n      let type =\n        refColumn == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn]).type;\n      let pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\nexport function addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\nexport function addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\n\nexport function removeColumn(tr, { map, table, tableStart }, col) {\n  let mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    let index = row * map.width + col,\n      pos = map.map[index],\n      cell = table.nodeAt(pos);\n    // If this is part of a col-spanning cell\n    if (\n      (col > 0 && map.map[index - 1] == pos) ||\n      (col < map.width - 1 && map.map[index + 1] == pos)\n    ) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(cell.attrs, col - map.colCount(pos)),\n      );\n    } else {\n      let start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += cell.attrs.rowspan;\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\nexport function deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      rect.table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\nexport function rowIsHeader(map, table, row) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\nexport function addRow(tr, { map, tableStart, table }, row) {\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  let cells = [],\n    refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (\n      row > 0 &&\n      row < map.height &&\n      map.map[index] == map.map[index - map.width]\n    ) {\n      let pos = map.map[index],\n        attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(\n        tableStart + pos,\n        null,\n        setAttr(attrs, 'rowspan', attrs.rowspan + 1),\n      );\n      col += attrs.colspan - 1;\n    } else {\n      let type =\n        refRow == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width]).type;\n      cells.push(type.createAndFill());\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\nexport function addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\nexport function addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\n\nexport function removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  let nextRow = rowPos + table.child(row).nodeSize;\n\n  let mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    let pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      let attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapFrom).map(pos + tableStart),\n        null,\n        setAttr(attrs, 'rowspan', attrs.rowspan - 1),\n      );\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      let cell = table.nodeAt(pos);\n      let copy = cell.type.create(\n        setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - 1),\n        cell.content,\n      );\n      let newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += cell.attrs.colspan - 1;\n    }\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\nexport function deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      rect.table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\nfunction isEmpty(cell) {\n  let c = cell.content;\n  return (\n    c.childCount == 1 &&\n    c.firstChild.isTextblock &&\n    c.firstChild.childCount == 0\n  );\n}\n\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left,\n    indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n    indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (\n      (rect.left > 0 && map[indexLeft] == map[indexLeft - 1]) ||\n      (rect.right < width && map[indexRight] == map[indexRight + 1])\n    )\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (\n      (rect.top > 0 && map[indexTop] == map[indexTop - width]) ||\n      (rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n    )\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\nexport function mergeCells(state, dispatch) {\n  let sel = state.selection;\n  if (\n    !(sel instanceof CellSelection) ||\n    sel.$anchorCell.pos == sel.$headCell.pos\n  )\n    return false;\n  let rect = selectedRect(state),\n    { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    let tr = state.tr,\n      seen = {},\n      content = Fragment.empty,\n      mergedPos,\n      mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let cellPos = map.map[row * map.width + col],\n          cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos]) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          let mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    tr.setNodeMarkup(\n      mergedPos + rect.tableStart,\n      null,\n      setAttr(\n        addColSpan(\n          mergedCell.attrs,\n          mergedCell.attrs.colspan,\n          rect.right - rect.left - mergedCell.attrs.colspan,\n        ),\n        'rowspan',\n        rect.bottom - rect.top,\n      ),\n    );\n    if (content.size) {\n      let end = mergedPos + 1 + mergedCell.content.size;\n      let start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)),\n    );\n    dispatch(tr);\n  }\n  return true;\n}\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\nexport function splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\n\n// :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\nexport function splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    let sel = state.selection;\n    let cellNode, cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = cellAround(sel.$from).pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs,\n        attrs = [],\n        colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = setAttr(baseAttrs, 'rowspan', 1);\n      if (baseAttrs.colspan > 1) baseAttrs = setAttr(baseAttrs, 'colspan', 1);\n      let rect = selectedRect(state),\n        tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth\n            ? setAttr(\n                baseAttrs,\n                'colwidth',\n                colwidth && colwidth[i] ? [colwidth[i]] : null,\n              )\n            : baseAttrs,\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            (lastCell = tr.mapping.map(pos + rect.tableStart, 1)),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i]),\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0],\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell && tr.doc.resolve(lastCell),\n          ),\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n// :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\nexport function setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      let tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value));\n        });\n      else\n        tr.setNodeMarkup(\n          $cell.pos,\n          null,\n          setAttr($cell.nodeAfter.attrs, name, value),\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n        tr = state.tr;\n      let cells = rect.map.cellsInRect(\n        type == 'column'\n          ? new Rect(rect.left, 0, rect.right, rect.map.height)\n          : type == 'row'\n          ? new Rect(0, rect.top, rect.map.width, rect.bottom)\n          : rect,\n      );\n      let nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (\n        let i = 0;\n        i < cells.length;\n        i++ // Remove headers, if any\n      )\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs,\n          );\n      if (tr.steps.length == 0)\n        for (\n          let i = 0;\n          i < cells.length;\n          i++ // No headers removed, add instead\n        )\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs,\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == 'row' ? rect.map.width : 1,\n    bottom: type == 'column' ? rect.map.height : 1,\n  });\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\nexport function toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n        tr = state.tr;\n\n      let isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);\n      let isHeaderColumnEnabled = isHeaderEnabledByType('column', rect, types);\n\n      let isHeaderEnabled =\n        type === 'column'\n          ? isHeaderRowEnabled\n          : type === 'row'\n          ? isHeaderColumnEnabled\n          : false;\n\n      let selectionStartsAt = isHeaderEnabled ? 1 : 0;\n\n      let cellsRect =\n        type == 'column'\n          ? new Rect(0, selectionStartsAt, 1, rect.map.height)\n          : type == 'row'\n          ? new Rect(selectionStartsAt, 0, rect.map.width, 1)\n          : rect;\n\n      let newType =\n        type == 'column'\n          ? isHeaderColumnEnabled\n            ? types.cell\n            : types.header_cell\n          : type == 'row'\n          ? isHeaderRowEnabled\n            ? types.cell\n            : types.header_cell\n          : types.cell;\n\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\nexport let toggleHeaderRow = toggleHeader('row', { useDeprecatedLogic: true });\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\nexport let toggleHeaderColumn = toggleHeader('column', {\n  useDeprecatedLogic: true,\n});\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\nexport let toggleHeaderCell = toggleHeader('cell', {\n  useDeprecatedLogic: true,\n});\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    let before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (\n      let row = $cell.index(-1) - 1, rowEnd = $cell.before();\n      row >= 0;\n      row--\n    ) {\n      let rowNode = $cell.node(-1).child(row);\n      if (rowNode.childCount) return rowEnd - 1 - rowNode.lastChild.nodeSize;\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1)\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    let table = $cell.node(-1);\n    for (\n      let row = $cell.indexAfter(-1), rowStart = $cell.after();\n      row < table.childCount;\n      row++\n    ) {\n      let rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n}\n\n// :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\nexport function goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return;\n    if (dispatch) {\n      let $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr\n          .setSelection(TextSelection.between($cell, moveCellForward($cell)))\n          .scrollIntoView(),\n      );\n    }\n    return true;\n  };\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\nexport function deleteTable(state, dispatch) {\n  let $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    let node = $pos.node(d);\n    if (node.type.spec.tableRole == 'table') {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView(),\n        );\n      return true;\n    }\n  }\n  return false;\n}\n", "export class TableView {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumns(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n\n  ignoreMutation(record) {\n    return (\n      record.type == 'attributes' &&\n      (record.target == this.table || this.colgroup.contains(record.target))\n    );\n  }\n}\n\nexport function updateColumns(\n  node,\n  colgroup,\n  table,\n  cellMinWidth,\n  overrideCol,\n  overrideValue,\n) {\n  let totalWidth = 0,\n    fixedWidth = true;\n  let nextDOM = colgroup.firstChild,\n    row = node.firstChild;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    let { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      let hasWidth =\n        overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      let cssWidth = hasWidth ? hasWidth + 'px' : '';\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width =\n          cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    let after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + 'px';\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = totalWidth + 'px';\n  }\n}\n", "import { Plugin, PluginKey } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { cellAround, pointsAtCell, setAttr } from './util';\nimport { TableMap } from './tablemap';\nimport { TableView, updateColumns } from './tableview';\nimport { tableNodeTypes } from './schema';\n\nexport const key = new PluginKey('tableColumnResizing');\n\nexport function columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true,\n} = {}) {\n  let plugin = new Plugin({\n    key,\n    state: {\n      init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (\n          node,\n          view,\n        ) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      },\n    },\n    props: {\n      attributes(state) {\n        let pluginState = key.getState(state);\n        return pluginState.activeHandle > -1\n          ? { class: 'resize-cursor' }\n          : null;\n      },\n\n      handleDOMEvents: {\n        mousemove(view, event) {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable,\n          );\n        },\n        mouseleave(view) {\n          handleMouseLeave(view);\n        },\n        mousedown(view, event) {\n          handleMouseDown(view, event, cellMinWidth);\n        },\n      },\n\n      decorations(state) {\n        let pluginState = key.getState(state);\n        if (pluginState.activeHandle > -1)\n          return handleDecorations(state, pluginState.activeHandle);\n      },\n\n      nodeViews: {},\n    },\n  });\n  return plugin;\n}\n\nclass ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n\n  apply(tr) {\n    let state = this,\n      action = tr.getMeta(key);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, null);\n    if (action && action.setDragging !== undefined)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) handle = null;\n      state = new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n}\n\nfunction handleMouseMove(\n  view,\n  event,\n  handleWidth,\n  cellMinWidth,\n  lastColumnResizable,\n) {\n  let pluginState = key.getState(view.state);\n\n  if (!pluginState.dragging) {\n    let target = domCellAround(event.target),\n      cell = -1;\n    if (target) {\n      let { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, 'left');\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, 'right');\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        let $cell = view.state.doc.resolve(cell);\n        let table = $cell.node(-1),\n          map = TableMap.get(table),\n          start = $cell.start(-1);\n        let col =\n          map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\n\nfunction handleMouseDown(view, event, cellMinWidth) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle == -1 || pluginState.dragging) return false;\n\n  let cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  let width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(key, {\n      setDragging: { startX: event.clientX, startWidth: width },\n    }),\n  );\n\n  function finish(event) {\n    window.removeEventListener('mouseup', finish);\n    window.removeEventListener('mousemove', move);\n    let pluginState = key.getState(view.state);\n    if (pluginState.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState.activeHandle,\n        draggedWidth(pluginState.dragging, event, cellMinWidth),\n      );\n      view.dispatch(view.state.tr.setMeta(key, { setDragging: null }));\n    }\n  }\n  function move(event) {\n    if (!event.which) return finish(event);\n    let pluginState = key.getState(view.state);\n    let dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n  }\n\n  window.addEventListener('mouseup', finish);\n  window.addEventListener('mousemove', move);\n  event.preventDefault();\n  return true;\n}\n\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  let width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  let dom = view.domAtPos(cellPos);\n  let node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth,\n    parts = colspan;\n  if (colwidth)\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  return domWidth / parts;\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != 'TD' && target.nodeName != 'TH')\n    target = target.classList.contains('ProseMirror')\n      ? null\n      : target.parentNode;\n  return target;\n}\n\nfunction edgeCell(view, event, side) {\n  let found = view.posAtCoords({ left: event.clientX, top: event.clientY });\n  if (!found) return -1;\n  let { pos } = found;\n  let $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == 'right') return $cell.pos;\n  let map = TableMap.get($cell.node(-1)),\n    start = $cell.start(-1);\n  let index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  let offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key, { setHandle: value }));\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    let mapIndex = row * map.width + col;\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    let pos = map.map[mapIndex],\n      { attrs } = table.nodeAt(pos);\n    let index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    let colwidth = attrs.colwidth\n      ? attrs.colwidth.slice()\n      : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, 'colwidth', colwidth));\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n    start = $cell.start(-1);\n  let col =\n    TableMap.get(table).colCount($cell.pos - start) +\n    $cell.nodeAfter.attrs.colspan -\n    1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom.nodeName != 'TABLE') dom = dom.parentNode;\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\n\nfunction zeroes(n) {\n  let result = [];\n  for (let i = 0; i < n; i++) result.push(0);\n  return result;\n}\n\nfunction handleDecorations(state, cell) {\n  let decorations = [];\n  let $cell = state.doc.resolve(cell);\n  let table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    let index = col + row * map.width - 1;\n    // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if (\n      (col == map.width || map.map[index] != map.map[index + 1]) &&\n      (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])\n    ) {\n      let cellPos = map.map[index];\n      let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      let dom = document.createElement('div');\n      dom.className = 'column-resize-handle';\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n  return DecorationSet.create(state.doc, decorations);\n}\n", "// This file defines a plugin that handles the drawing of cell\n// selections and the basic user interactions for creating and working\n// with such selections. It also makes sure that, after each\n// transaction, the shapes of tables are normalized to be rectangular\n// and not contain overlapping cells.\n\nimport { Plugin } from 'prosemirror-state';\n\nimport {\n  handleTripleClick,\n  handleKeyDown,\n  handlePaste,\n  handleMouseDown,\n} from './input';\nimport { key as tableEditingKey } from './util';\nimport { drawCellSelection, normalizeSelection } from './cellselection';\nimport { fixTables, fixTablesKey } from './fixtables';\n\n// :: () → Plugin\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\nexport function tableEditing({ allowTableNodeSelection = false } = {}) {\n  return new Plugin({\n    key: tableEditingKey,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        let set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        let { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      },\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown,\n      },\n\n      createSelectionBetween(view) {\n        if (tableEditingKey.getState(view.state) != null)\n          return view.state.selection;\n      },\n\n      handleTripleClick,\n\n      handleKeyDown,\n\n      handlePaste,\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection,\n      );\n    },\n  });\n}\n\nexport { fixTables, handlePaste, fixTablesKey };\nexport {\n  cellAround,\n  isInTable,\n  selectionCell,\n  moveCellForward,\n  inSameTable,\n  findCell,\n  colCount,\n  nextCell,\n  setAttr,\n  pointsAtCell,\n  removeColSpan,\n  addColSpan,\n  columnIsHeader,\n} from './util';\nexport { tableNodes, tableNodeTypes } from './schema';\nexport { CellSelection } from './cellselection';\nexport { TableMap } from './tablemap';\nexport { tableEditingKey };\nexport * from './commands';\nexport {\n  columnResizing,\n  key as columnResizingPluginKey,\n} from './columnresizing';\nexport { updateColumns as updateColumnsOnResize, TableView } from './tableview';\nexport {\n  pastedCells as __pastedCells,\n  insertCells as __insertCells,\n  clipCells as __clipCells,\n} from './copypaste';\n", "// @ts-nocheck\nimport { Node as ProseMirrorNode } from 'prosemirror-model'\nimport { NodeView } from 'prosemirror-view'\n\nexport function updateColumns(node: ProseMirrorNode, colgroup: Element, table: Element, cellMinWidth: number, overrideCol?: number, overrideValue?: any) {\n  let totalWidth = 0\n  let fixedWidth = true\n  let nextDOM = colgroup.firstChild\n  const row = node.firstChild\n\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const { colspan, colwidth } = row.child(i).attrs\n\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j]\n      const cssWidth = hasWidth ? `${hasWidth}px` : ''\n\n      totalWidth += hasWidth || cellMinWidth\n\n      if (!hasWidth) {\n        fixedWidth = false\n      }\n\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width = cssWidth\n      } else {\n        if (nextDOM.style.width !== cssWidth) {\n          nextDOM.style.width = cssWidth\n        }\n\n        nextDOM = nextDOM.nextSibling\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling\n\n    nextDOM.parentNode.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  if (fixedWidth) {\n    table.style.width = `${totalWidth}px`\n    table.style.minWidth = ''\n  } else {\n    table.style.width = ''\n    table.style.minWidth = `${totalWidth}px`\n  }\n}\n\nexport class TableView implements NodeView {\n\n  node: ProseMirrorNode\n\n  cellMinWidth: number\n\n  dom: Element\n\n  table: Element\n\n  colgroup: Element\n\n  contentDOM: Element\n\n  constructor(node: ProseMirrorNode, cellMinWidth: number) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement('div')\n    this.dom.className = 'tableWrapper'\n    this.table = this.dom.appendChild(document.createElement('table'))\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'))\n  }\n\n  update(node: ProseMirrorNode) {\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n\n    return true\n  }\n\n  ignoreMutation(mutation: MutationRecord | { type: 'selection'; target: Element }) {\n    return mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target))\n  }\n}\n", "import { Fragment, Node as ProsemirrorNode, NodeType } from 'prosemirror-model'\n\nexport function createCell(cellType: NodeType, cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>): ProsemirrorNode | null | undefined {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent)\n  }\n\n  return cellType.createAndFill()\n}\n", "import { NodeType, Schema } from 'prosemirror-model'\n\nexport function getTableNodeTypes(schema: Schema): { [key: string]: NodeType } {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes\n  }\n\n  const roles: { [key: string]: NodeType } = {}\n\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type]\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType\n    }\n  })\n\n  schema.cached.tableNodeTypes = roles\n\n  return roles\n}\n", "import { Fragment, Node as ProsemirrorNode, Schema } from 'prosemirror-model'\n\nimport { createCell } from './createCell'\nimport { getTableNodeTypes } from './getTableNodeTypes'\n\nexport function createTable(schema: Schema, rowsCount: number, colsCount: number, withHeaderRow: boolean, cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>): ProsemirrorNode {\n  const types = getTableNodeTypes(schema)\n  const headerCells: ProsemirrorNode[] = []\n  const cells: ProsemirrorNode[] = []\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent)\n\n    if (cell) {\n      cells.push(cell)\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent)\n\n      if (headerCell) {\n        headerCells.push(headerCell)\n      }\n    }\n  }\n\n  const rows: ProsemirrorNode[] = []\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells))\n  }\n\n  return types.table.createChecked(null, rows)\n}\n", "import { CellSelection } from '@_ueberdosis/prosemirror-tables'\n\nexport function isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection\n}\n", "import { findParentNodeClosestToPos, KeyboardShortcutCommand } from '@tiptap/core'\n\nimport { isCellSelection } from './isCellSelection'\n\nexport const deleteTableWhenAllCellsSelected: KeyboardShortcutCommand = ({ editor }) => {\n  const { selection } = editor.state\n\n  if (!isCellSelection(selection)) {\n    return false\n  }\n\n  let cellCount = 0\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table'\n  })\n\n  table?.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false\n    }\n\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1\n    }\n  })\n\n  const allCellsSelected = cellCount === selection.ranges.length\n\n  if (!allCellsSelected) {\n    return false\n  }\n\n  editor.commands.deleteTable()\n\n  return true\n}\n", "import {\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  CellSelection,\n  columnResizing,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  fixTables,\n  goToNextCell,\n  mergeCells,\n  setCellAttr,\n  splitCell,\n  tableEditing,\n  toggleHeader,\n  toggleHeaderCell,\n} from '@_ueberdosis/prosemirror-tables'\nimport {\n  callOrReturn,\n  getExtensionField,\n  mergeAttributes,\n  Node,\n  ParentConfig,\n} from '@tiptap/core'\nimport { TextSelection } from 'prosemirror-state'\nimport { NodeView } from 'prosemirror-view'\n\nimport { TableView } from './TableView'\nimport { createTable } from './utilities/createTable'\nimport { deleteTableWhenAllCellsSelected } from './utilities/deleteTableWhenAllCellsSelected'\n\nexport interface TableOptions {\n  HTMLAttributes: Record<string, any>,\n  resizable: boolean,\n  handleWidth: number,\n  cellMinWidth: number,\n  View: NodeView,\n  lastColumnResizable: boolean,\n  allowTableNodeSelection: boolean,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    table: {\n      insertTable: (options?: { rows?: number, cols?: number, withHeaderRow?: boolean }) => ReturnType,\n      addColumnBefore: () => ReturnType,\n      addColumnAfter: () => ReturnType,\n      deleteColumn: () => ReturnType,\n      addRowBefore: () => ReturnType,\n      addRowAfter: () => ReturnType,\n      deleteRow: () => ReturnType,\n      deleteTable: () => ReturnType,\n      mergeCells: () => ReturnType,\n      splitCell: () => ReturnType,\n      toggleHeaderColumn: () => ReturnType,\n      toggleHeaderRow: () => ReturnType,\n      toggleHeaderCell: () => ReturnType,\n      mergeOrSplit: () => ReturnType,\n      setCellAttribute: (name: string, value: any) => ReturnType,\n      goToNextCell: () => ReturnType,\n      goToPreviousCell: () => ReturnType,\n      fixTables: () => ReturnType,\n      setCellSelection: (position: { anchorCell: number, headCell?: number }) => ReturnType,\n    }\n  }\n\n  interface NodeConfig<Options, Storage> {\n    /**\n     * Table Role\n     */\n    tableRole?: string | ((this: {\n      name: string,\n      options: Options,\n      storage: Storage,\n      parent: ParentConfig<NodeConfig<Options>>['tableRole'],\n    }) => string),\n  }\n}\n\nexport const Table = Node.create<TableOptions>({\n  name: 'table',\n\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false,\n    }\n  },\n\n  content: 'tableRow+',\n\n  tableRole: 'table',\n\n  isolating: true,\n\n  group: 'block',\n\n  parseHTML() {\n    return [\n      { tag: 'table' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]]\n  },\n\n  addCommands() {\n    return {\n      insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n        const node = createTable(editor.schema, rows, cols, withHeaderRow)\n\n        if (dispatch) {\n          const offset = tr.selection.anchor + 1\n\n          tr.replaceSelectionWith(node)\n            .scrollIntoView()\n            .setSelection(TextSelection.near(tr.doc.resolve(offset)))\n        }\n\n        return true\n      },\n      addColumnBefore: () => ({ state, dispatch }) => {\n        return addColumnBefore(state, dispatch)\n      },\n      addColumnAfter: () => ({ state, dispatch }) => {\n        return addColumnAfter(state, dispatch)\n      },\n      deleteColumn: () => ({ state, dispatch }) => {\n        return deleteColumn(state, dispatch)\n      },\n      addRowBefore: () => ({ state, dispatch }) => {\n        return addRowBefore(state, dispatch)\n      },\n      addRowAfter: () => ({ state, dispatch }) => {\n        return addRowAfter(state, dispatch)\n      },\n      deleteRow: () => ({ state, dispatch }) => {\n        return deleteRow(state, dispatch)\n      },\n      deleteTable: () => ({ state, dispatch }) => {\n        return deleteTable(state, dispatch)\n      },\n      mergeCells: () => ({ state, dispatch }) => {\n        return mergeCells(state, dispatch)\n      },\n      splitCell: () => ({ state, dispatch }) => {\n        return splitCell(state, dispatch)\n      },\n      toggleHeaderColumn: () => ({ state, dispatch }) => {\n        return toggleHeader('column')(state, dispatch)\n      },\n      toggleHeaderRow: () => ({ state, dispatch }) => {\n        return toggleHeader('row')(state, dispatch)\n      },\n      toggleHeaderCell: () => ({ state, dispatch }) => {\n        return toggleHeaderCell(state, dispatch)\n      },\n      mergeOrSplit: () => ({ state, dispatch }) => {\n        if (mergeCells(state, dispatch)) {\n          return true\n        }\n\n        return splitCell(state, dispatch)\n      },\n      setCellAttribute: (name, value) => ({ state, dispatch }) => {\n        return setCellAttr(name, value)(state, dispatch)\n      },\n      goToNextCell: () => ({ state, dispatch }) => {\n        return goToNextCell(1)(state, dispatch)\n      },\n      goToPreviousCell: () => ({ state, dispatch }) => {\n        return goToNextCell(-1)(state, dispatch)\n      },\n      fixTables: () => ({ state, dispatch }) => {\n        if (dispatch) {\n          fixTables(state)\n        }\n\n        return true\n      },\n      setCellSelection: position => ({ tr, dispatch }) => {\n        if (dispatch) {\n          const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell)\n\n          // @ts-ignore\n          tr.setSelection(selection)\n        }\n\n        return true\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true\n        }\n\n        if (!this.editor.can().addRowAfter()) {\n          return false\n        }\n\n        return this.editor\n          .chain()\n          .addRowAfter()\n          .goToNextCell()\n          .run()\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable\n\n    return [\n      ...(isResizable ? [columnResizing({\n        handleWidth: this.options.handleWidth,\n        cellMinWidth: this.options.cellMinWidth,\n        View: this.options.View,\n        // TODO: PR for @types/prosemirror-tables\n        // @ts-ignore (incorrect type)\n        lastColumnResizable: this.options.lastColumnResizable,\n      })] : []),\n      tableEditing({\n        allowTableNodeSelection: this.options.allowTableNodeSelection,\n      }),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n    }\n  },\n})\n"],
  "mappings": "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",
  "names": ["readFromCache", "addToCache", "WeakMap", "cache", "key", "get", "value", "set", "cacheSize", "cachePos", "i", "length", "Rect", "constructor", "left", "top", "right", "bottom", "TableMap", "width", "height", "map", "problems", "findCell", "pos", "curPos", "j", "RangeError", "colCount", "nextCell", "axis", "dir", "rectBetween", "a", "b", "leftA", "rightA", "topA", "bottomA", "leftB", "rightB", "topB", "bottomB", "Math", "min", "max", "cellsInRect", "rect", "result", "seen", "row", "col", "index", "push", "positionAt", "table", "rowStart", "rowEnd", "child", "nodeSize", "rowEndIndex", "computeMap", "type", "spec", "tableRole", "name", "findWidth", "childCount", "mapPos", "colWidths", "e", "rowNode", "cellNode", "colspan", "rowspan", "colwidth", "attrs", "h", "n", "start", "w", "colW", "widthIndex", "prev", "expectedPos", "missing", "tableMap", "badWidths", "findBadColWidths", "hasRowSpan", "rowWidth", "prevRow", "cell", "node", "nodeAt", "updated", "colWidth", "freshColWidth", "unshift", "slice", "tableNodeTypes", "schema", "result", "cached", "name", "nodes", "type", "role", "spec", "tableRole", "key", "PluginKey", "cellAround", "$pos", "d", "depth", "node", "resolve", "before", "cellWrapping", "isInTable", "state", "$head", "selection", "selectionCell", "sel", "$anchorCell", "pos", "$headCell", "$anchor", "cellNear", "after", "nodeAfter", "firstChild", "doc", "nodeBefore", "lastChild", "nodeSize", "pointsAtCell", "parent", "moveCellForward", "inSameTable", "$a", "$b", "start", "end", "nextCell", "$pos", "axis", "dir", "start", "map", "TableMap", "get", "node", "moved", "pos", "resolve", "setAttr", "attrs", "name", "value", "result", "prop", "removeColSpan", "n", "colspan", "colwidth", "slice", "splice", "some", "w", "addColSpan", "i", "columnIsHeader", "table", "col", "headerCell", "tableNodeTypes", "type", "schema", "header_cell", "row", "height", "nodeAt", "width", "CellSelection", "Selection", "constructor", "$anchorCell", "$headCell", "rect", "rectBetween", "doc", "cells", "cellsInRect", "filter", "p", "unshift", "ranges", "cell", "from", "SelectionRange", "content", "size", "$from", "$to", "mapping", "pointsAtCell", "inSameTable", "tableChanged", "isRowSelection", "rowSelection", "isColSelection", "colSelection", "TextSelection", "between", "seen", "rows", "top", "bottom", "rowContent", "index", "left", "right", "cellRect", "findCell", "extraLeft", "extraRight", "createAndFill", "create", "Math", "min", "max", "push", "child", "copy", "Fragment", "fragment", "Slice", "replace", "tr", "empty", "mapFrom", "steps", "length", "sel", "findFrom", "to", "setSelection", "replaceWith", "forEachCell", "f", "anchorTop", "headTop", "anchorBot", "nodeAfter", "rowspan", "headBot", "childCount", "anchorRect", "headRect", "anchorLeft", "colCount", "headLeft", "anchorRight", "headRight", "eq", "other", "toJSON", "anchor", "head", "fromJSON", "json", "anchorCell", "headCell", "getBookmark", "CellBookmark", "prototype", "visible", "jsonID", "parent", "spec", "tableRole", "near", "drawCellSelection", "state", "selection", "Decoration", "nodeSize", "class", "DecorationSet", "isCellBoundarySelection", "afterFrom", "beforeTo", "depth", "after", "end", "d", "before", "test", "isTextSelectionAcrossCells", "fromCellBoundaryNode", "toCellBoundaryNode", "parentOffset", "normalizeSelection", "allowTableNodeSelection", "normalize", "role", "NodeSelection", "$cell", "lastCell", "pastedCells", "openStart", "openEnd", "firstChild", "first", "fitSlice", "ensureRectangular", "widths", "j", "r", "append", "nodeType", "Transform", "clipCells", "newWidth", "newHeight", "added", "newRows", "frag", "source", "growTable", "types", "emptyHead", "rowEnd", "rowNode", "add", "lastChild", "insert", "header", "emptyRow", "isolateHorizontal", "found", "cellTop", "cellLeft", "setNodeMarkup", "positionAt", "isolateVertical", "updatePos", "insertCells", "dispatch", "tableStart", "recomp", "maps", "handleKeyDown", "keydownHandler", "ArrowLeft", "arrow", "ArrowRight", "ArrowUp", "ArrowDown", "shiftArrow", "Backspace", "deleteCellSelection", "Delete", "maybeSetSelection", "scrollIntoView", "view", "atEndOfCell", "$next", "newSel", "$head", "baseContent", "docChanged", "handleTripleClick", "cellAround", "handlePaste", "_", "isInTable", "selectionCell", "handleMouseDown", "startEvent", "ctrlKey", "metaKey", "startDOMCell", "domInCell", "target", "$anchor", "shiftKey", "setCellSelection", "preventDefault", "cellUnderMouse", "event", "starting", "key", "getState", "setMeta", "stop", "root", "removeEventListener", "move", "addEventListener", "indexAfter", "cellPos", "dirStr", "endOfTextblock", "dom", "parentNode", "nodeName", "mousePos", "posAtCoords", "clientX", "clientY", "fixTablesKey", "PluginKey", "changedDescendants", "old", "cur", "offset", "oldSize", "curSize", "outer", "scan", "e", "sameMarkup", "nodesBetween", "fixTables", "oldState", "check", "fixTable", "descendants", "tablePos", "problems", "mustAdd", "prob", "last", "tableNodeType", "nodes", "side", "selectedRect", "addColumn", "refColumn", "addColumnBefore", "addColumnAfter", "removeColumn", "mapStart", "delete", "deleteColumn", "rowIsHeader", "addRow", "rowPos", "refRow", "addRowBefore", "addRowAfter", "removeRow", "nextRow", "newPos", "deleteRow", "isEmpty", "c", "isTextblock", "cellsOverlapRectangle", "indexTop", "indexLeft", "indexBottom", "indexRight", "mergeCells", "mergedPos", "mergedCell", "mapped", "splitCell", "nodeTypes", "splitCellWithType", "getCellType", "cellNode", "cellWrapping", "baseAttrs", "setCellAttr", "deprecated_toggleHeader", "Rect", "isHeaderEnabledByType", "cellPositions", "toggleHeader", "options", "useDeprecatedLogic", "isHeaderRowEnabled", "isHeaderColumnEnabled", "isHeaderEnabled", "selectionStartsAt", "cellsRect", "newType", "forEach", "relativeCellPos", "toggleHeaderRow", "toggleHeaderColumn", "toggleHeaderCell", "findNextCell", "nodeBefore", "rowStart", "goToNextCell", "direction", "moveCellForward", "deleteTable", "TableView", "cellMinWidth", "document", "createElement", "className", "appendChild", "colgroup", "updateColumns", "contentDOM", "update", "ignoreMutation", "record", "contains", "overrideCol", "overrideValue", "totalWidth", "fixedWidth", "nextDOM", "hasWidth", "cssWidth", "style", "nextSibling", "removeChild", "minWidth", "columnResizing", "handleWidth", "View", "lastColumnResizable", "plugin", "Plugin", "init", "props", "nodeViews", "ResizeState", "apply", "prev", "attributes", "pluginState", "activeHandle", "handleDOMEvents", "mousemove", "handleMouseMove", "mouseleave", "handleMouseLeave", "mousedown", "decorations", "handleDecorations", "dragging", "action", "getMeta", "setHandle", "setDragging", "undefined", "handle", "domCellAround", "getBoundingClientRect", "edgeCell", "updateHandle", "currentColWidth", "startX", "startWidth", "finish", "window", "updateColumnWidth", "draggedWidth", "which", "dragged", "displayColumnWidth", "domAtPos", "childNodes", "domWidth", "offsetWidth", "parts", "classList", "indexOf", "mapIndex", "zeroes", "widget", "tableEditing", "tableEditingKey", "set", "deleted", "mapResult", "createSelectionBetween", "appendTransaction", "updateColumns", "TableView"]
}
